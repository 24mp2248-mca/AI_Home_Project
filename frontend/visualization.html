<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Visualization | AI Home Planner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: #dff3fb; overflow: hidden; height: 100vh; font-family: 'Segoe UI', sans-serif; }
    
    #header { position: fixed; top: 0; left: 0; right: 0; height: 70px; background: transparent; display: flex; align-items: center; justify-content: space-between; padding: 0 30px; z-index: 1000; }
    .logo { font-size: 1.2rem; font-weight: 700; color: #333; }
    .btn { padding: 10px 16px; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; margin-left: 10px; }
    .btn-secondary { background: rgba(255, 255, 255, 0.7); color: #333; }
    .btn-primary { background: #667eea; color: white; }
    
    .sidebar { position: fixed; left: 18px; top: 22px; width: 220px; height: auto; background: #ffffff; border-radius: 12px; padding: 18px; overflow: visible; z-index: 100; box-shadow: 0 10px 30px rgba(20,30,60,0.12); }
    .sidebar h3 { color: #2b2b2b; font-size: 1rem; margin-bottom: 12px; display:flex; align-items:center; gap:8px }
    .control-group label { display: flex; align-items: center; gap: 10px; color: #333; font-size: 0.95rem; margin-bottom: 8px; cursor: pointer; }
    .control-group input { accent-color: #2ecc71; }
    
    .view-buttons { display: grid; grid-template-columns: 1fr; gap: 10px; margin: 10px 0; }
    .view-btn { padding: 10px; background: #2ecc71; border: none; color: white; border-radius: 6px; font-size: 0.9rem; cursor: pointer; box-shadow: 0 6px 12px rgba(46,204,113,0.18); }
    .view-btn.active { opacity: 0.98; }
    
    .info-panel { background: transparent; border-radius: 6px; padding: 8px 0; margin: 10px 0; }
    .info-item { display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 0.9rem; color: #555; }
    .info-item strong { color: #111; }
    
    #canvas-container { position: fixed; left: 0; top: 0; right: 0; bottom: 0; background: linear-gradient(#cfeef9, #dff3fb 60%); }

    /* Room labels - DOM overlay on canvas */
    .room-label {
      position: fixed;
      background: white;
      padding: 6px 12px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 13px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      pointer-events: none;
      transform: translate(-50%, -50%);
      z-index: 50;
      white-space: nowrap;
    }
    .room-label.living { color: #5b6cf7; }
    .room-label.kitchen { color: #ff7f50; }
    .room-label.bedroom { color: #2ecc71; }
    .room-label.bathroom { color: #4aa3ff; }
    .room-label.carport { color: #f39c12; }

    .loading-screen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); z-index: 2000; }
    .spinner { width: 50px; height: 50px; border: 4px solid rgba(255, 255, 255, 0.3); border-top: 4px solid white; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .loading-content { text-align: center; color: white; }
  </style>
</head>
<body>

  <div id="loading-screen" class="loading-screen">
    <div class="loading-content">
      <div class="spinner"></div>
      <h2>Loading 3D Visualization</h2>
      <p>Processing your floor plan...</p>
    </div>
  </div>

  <div id="header">
    <div class="logo">üè† AI Home Planner - 3D View</div>
    <div>
      <button class="btn btn-secondary" onclick="goBack()">‚Üê Back</button>
      <button class="btn btn-primary" onclick="downloadVisualization()">üì• Download</button>
    </div>
  </div>

  <div class="sidebar">
    <h3>üéÆ Controls</h3>
    <div class="control-group">
      <label><input type="checkbox" id="toggle-labels" checked> Room Labels</label>
      <label><input type="checkbox" id="toggle-furniture" checked> Furniture</label>
      <label><input type="checkbox" id="toggle-walls" checked> Walls</label>
      <label><input type="checkbox" id="toggle-roof"> Show Roof</label>
      <label><input type="checkbox" id="toggle-auto-rotate"> Auto Rotate</label>
    </div>

    <div class="view-buttons">
      <button class="view-btn" onclick="window.setView('iso')">3D View</button>
      <button class="view-btn" onclick="window.setView('top')">Top View</button>
      <button class="view-btn active" onclick="window.setView('interior')">Interior</button>
      <button class="view-btn" onclick="window.setView('side')">Side View</button>
    </div>

    <div class="info-panel">
      <div class="info-item"><span>Total Rooms:</span><strong id="room-count">0</strong></div>
      <div class="info-item"><span>Total Area:</span><strong id="total-area">0</strong> m¬≤</div>
      <div class="info-item"><span>Est. Cost:</span><strong id="est-cost">$0</strong></div>
    </div>

    <div class="room-list">
      <strong style="color: #333; font-size: 0.85rem;">Rooms:</strong>
      <div id="room-list"></div>
    </div>
  </div>

  <div id="canvas-container"></div>
  <div id="labels-container"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    function initScene() {
      const container = document.getElementById('canvas-container');
      const w = window.innerWidth;
      const h = window.innerHeight;

      // Create scene, camera, renderer
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xcfeef9);
      scene.fog = new THREE.Fog(0xcfeef9, 200, 800);

      const camera = new THREE.PerspectiveCamera(55, w / h, 0.1, 1000);
      camera.position.set(15, 8, 15);
      camera.lookAt(10, 3, 10);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(w, h);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFShadowShadowMap;
      container.appendChild(renderer.domElement);

      // Orbit controls
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.06;
      controls.enablePan = true;
      controls.enableZoom = true;
      controls.autoRotate = false;
      controls.autoRotateSpeed = 2;
      controls.target.set(10, 3, 10);

      // Lights
      const ambient = new THREE.AmbientLight(0xffffff, 0.9);
      scene.add(ambient);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
      dirLight.position.set(80, 80, 80);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;
      dirLight.shadow.camera.far = 500;
      dirLight.shadow.camera.left = -150;
      dirLight.shadow.camera.right = 150;
      dirLight.shadow.camera.top = 150;
      dirLight.shadow.camera.bottom = -150;
      scene.add(dirLight);

      const fillLight = new THREE.DirectionalLight(0x9ec8f7, 0.5);
      fillLight.position.set(-60, 40, -60);
      scene.add(fillLight);

      // Ground (friendly green lawn)
      const groundGeo = new THREE.PlaneGeometry(400, 400);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0xc8f87a, roughness: 0.9 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      const gridHelper = new THREE.GridHelper(200, 20, 0x66bb33, 0x88ff66);
      gridHelper.position.y = 0.01;
      scene.add(gridHelper);

      // Groups
      const roomsGroup = new THREE.Group();
      const furnitureGroup = new THREE.Group();
      const wallsGroup = new THREE.Group();
      const roofGroup = new THREE.Group();

      scene.add(roomsGroup);
      scene.add(furnitureGroup);
      scene.add(wallsGroup);
      scene.add(roofGroup);

      const roomColors = [0x667eea, 0x764ba2, 0x2a9d8f, 0xf4a261, 0xe76f51];

      // Materials
      const wallMat = new THREE.MeshStandardMaterial({ color: 0xf5f5f5, roughness: 0.7 });
      const roofMat = new THREE.MeshStandardMaterial({ color: 0xb22222, roughness: 0.8 });

      function createWall(w, h, d, x, y, z) {
        const wall = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), wallMat);
        wall.position.set(x, y, z);
        wall.castShadow = true;
        wall.receiveShadow = true;
        wallsGroup.add(wall);
      }

      function createRoof(x, z, len, wid) {
        const size = Math.max(len, wid) / 1.1;
        const roof = new THREE.Mesh(new THREE.ConeGeometry(size, 3.2, 4), roofMat);
        roof.rotation.y = Math.PI / 4;
        roof.position.set(x, 1.8 + 1.0, z);
        roof.castShadow = true;
        roof.receiveShadow = true;
        roof.scale.set(1.02, 1, 1.02);
        roofGroup.add(roof);
      }

      function createFurniture(type, x, y, z, size) {
        const group = new THREE.Group();
        
        if (type === 'sofa') {
          const sofa = new THREE.Mesh(
            new THREE.BoxGeometry(size, 1.0, size * 0.6),
            new THREE.MeshStandardMaterial({ color: 0x2d6a4f, metalness: 0.1, roughness: 0.6 })
          );
          sofa.position.set(x, 0.5, z);
          sofa.castShadow = true;
          sofa.receiveShadow = true;
          group.add(sofa);
        } else if (type === 'bed') {
          const bed = new THREE.Mesh(
            new THREE.BoxGeometry(size * 1.2, 0.8, size * 1.4),
            new THREE.MeshStandardMaterial({ color: 0x7b61ff, metalness: 0.05, roughness: 0.5 })
          );
          bed.position.set(x, 0.4, z);
          bed.castShadow = true;
          bed.receiveShadow = true;
          group.add(bed);
        } else if (type === 'sink') {
          const sink = new THREE.Mesh(
            new THREE.BoxGeometry(size * 0.8, 1.2, size * 0.5),
            new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.2 })
          );
          sink.position.set(x, 0.6, z);
          sink.castShadow = true;
          sink.receiveShadow = true;
          group.add(sink);
        } else if (type === 'stove') {
          const stove = new THREE.Mesh(
            new THREE.BoxGeometry(size * 0.9, 1.1, size * 0.8),
            new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.6, roughness: 0.4 })
          );
          stove.position.set(x, 0.55, z);
          stove.castShadow = true;
          stove.receiveShadow = true;
          group.add(stove);
        } else if (type === 'toilet') {
          const toilet = new THREE.Mesh(
            new THREE.CylinderGeometry(size * 0.3, size * 0.3, 0.9, 16),
            new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.7, roughness: 0.3 })
          );
          toilet.position.set(x, 0.45, z);
          toilet.castShadow = true;
          toilet.receiveShadow = true;
          group.add(toilet);
        } else {
          const table = new THREE.Mesh(
            new THREE.BoxGeometry(size * 1.0, 0.08, size * 1.0),
            new THREE.MeshStandardMaterial({ color: 0x8B4513, metalness: 0.3, roughness: 0.6 })
          );
          table.position.set(x, 0.9, z);
          table.castShadow = true;
          table.receiveShadow = true;
          group.add(table);
        }
        
        return group;
      }

      // Project data - realistic house layout with carport
      let projectData = {
        rooms: [
          { id: "R1", type: "Living Room", dimensions: { length: 14, width: 12, height: 3.5 }, position: { x: 0, y: 0 } },
          { id: "R2", type: "Kitchen", dimensions: { length: 10, width: 8, height: 3.5 }, position: { x: 18, y: 0 } },
          { id: "R3", type: "Bedroom", dimensions: { length: 12, width: 10, height: 3.5 }, position: { x: 0, y: 18 } },
          { id: "R4", type: "Bathroom", dimensions: { length: 6, width: 5, height: 3.5 }, position: { x: 18, y: 18 } },
          { id: "R5", type: "Carport", dimensions: { length: 10, width: 8, height: 2.8 }, position: { x: 28, y: 9 } }
        ],
        totalArea: 522,
        estimatedCost: 78300
      };

      // Load from sessionStorage or localStorage
      try {
        // Try sessionStorage first, then localStorage
        let stored = sessionStorage.getItem('roomData');
        if (!stored || stored === '[]' || stored === 'undefined') {
          stored = localStorage.getItem('roomData');
        }
        
        console.log('Checking storage for roomData...');
        console.log('Stored value:', stored);
        
        if (stored && stored !== '[]' && stored !== 'undefined') {
          projectData.rooms = JSON.parse(stored);
          console.log('Loaded rooms from storage:', projectData.rooms);
        } else {
          console.log('No valid room data in storage, using default demo data');
        }
      } catch (e) {
        console.error('Error loading from storage:', e);
        console.log('Using default demo data instead');
      }

      function renderRooms() {
        roomsGroup.clear();
        furnitureGroup.clear();
        wallsGroup.clear();
        roofGroup.clear();

        console.log('Rendering rooms...');
        projectData.rooms.forEach((room, idx) => {
          const color = roomColors[idx % roomColors.length];
          
          console.log(`Processing room: ${room.type} at position (${room.position.x}, ${room.position.y})`);
          
          const material = new THREE.MeshStandardMaterial({
            color: color,
            metalness: 0.2,
            roughness: 0.7
          });
          
          const geo = new THREE.BoxGeometry(
            room.dimensions.length,
            room.dimensions.height,
            room.dimensions.width
          );
          
          const mesh = new THREE.Mesh(geo, material);
          mesh.position.set(
            room.position.x,
            room.dimensions.height / 2,
            room.position.y
          );
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          roomsGroup.add(mesh);

          // Walls
          const w = room.dimensions.length;
          const h = room.dimensions.height;
          const d = room.dimensions.width;
          createWall(w, h, 0.2, room.position.x, h / 2, room.position.y - d / 2);
          createWall(w, h, 0.2, room.position.x, h / 2, room.position.y + d / 2);
          createWall(0.2, h, d, room.position.x - w / 2, h / 2, room.position.y);
          createWall(0.2, h, d, room.position.x + w / 2, h / 2, room.position.y);

          // Roof
          createRoof(room.position.x, room.position.y, w, d);

          // Furniture - multiple items per room with better sizes
          if (room.type.includes('Living')) {
            const sofa = createFurniture('sofa', room.position.x - 4, 0, room.position.y - 4, 4);
            furnitureGroup.add(sofa);
            const table = createFurniture('table', room.position.x + 3, 0, room.position.y + 2, 3);
            furnitureGroup.add(table);
          } else if (room.type.includes('Kitchen')) {
            const stove = createFurniture('stove', room.position.x - 3, 0, room.position.y - 2, 2.5);
            furnitureGroup.add(stove);
            const sink = createFurniture('sink', room.position.x + 2.5, 0, room.position.y - 1.5, 2);
            furnitureGroup.add(sink);
            const table = createFurniture('table', room.position.x - 1, 0, room.position.y + 3, 2.5);
            furnitureGroup.add(table);
          } else if (room.type.includes('Bedroom')) {
            const bed = createFurniture('bed', room.position.x - 3, 0, room.position.y - 1, 4.5);
            furnitureGroup.add(bed);
            const table = createFurniture('table', room.position.x + 3, 0, room.position.y + 3, 2);
            furnitureGroup.add(table);
          } else if (room.type.includes('Bathroom')) {
            const toilet = createFurniture('toilet', room.position.x - 1.5, 0, room.position.y - 1.5, 2);
            furnitureGroup.add(toilet);
            const sink = createFurniture('sink', room.position.x + 1.5, 0, room.position.y + 1.5, 1.8);
            furnitureGroup.add(sink);
          }
        });

        console.log(`Total furniture pieces added: ${furnitureGroup.children.length}`);
        updateUI();
      }

      function updateUI() {
        document.getElementById('room-count').textContent = projectData.rooms.length;
        document.getElementById('total-area').textContent = projectData.totalArea.toFixed(1);
        document.getElementById('est-cost').textContent = '$' + projectData.estimatedCost;

        const roomList = document.getElementById('room-list');
        roomList.innerHTML = projectData.rooms.map((room, idx) => {
          const area = room.dimensions.length * room.dimensions.width;
          const hex = roomColors[idx % roomColors.length].toString(16).padStart(6, '0');
          return `
            <div style="display:flex;align-items:center;gap:8px;padding:6px;margin-bottom:4px;font-size:0.85rem;color:#555;">
              <div style="width:12px;height:12px;border-radius:2px;background-color:#${hex}"></div>
              <span>${room.type} - ${area.toFixed(1)} m¬≤</span>
            </div>
          `;
        }).join('');
      }

      // Room labels - DOM-based for visibility
      function updateLabels() {
        const labelsContainer = document.getElementById('labels-container');
        labelsContainer.innerHTML = '';

        projectData.rooms.forEach((room, idx) => {
          const vector = new THREE.Vector3(room.position.x, room.dimensions.height + 0.5, room.position.y);
          vector.project(camera);

          const x = (vector.x * 0.5 + 0.5) * w;
          const y = (-vector.y * 0.5 + 0.5) * h;

          const label = document.createElement('div');
          label.className = 'room-label ' + room.type.toLowerCase().replace(' ', '');
          label.textContent = room.type;
          label.style.left = x + 'px';
          label.style.top = y + 'px';
          labelsContainer.appendChild(label);
        });
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
        
        if (document.getElementById('toggle-labels').checked) {
          updateLabels();
        }
      }

      // View presets
      window.setView = function(view) {
        const views = {
          'iso': { x: 25, y: 20, z: 25 },
          'top': { x: 0, y: 100, z: 0 },
          'interior': { x: 15, y: 8, z: 15 },
          'side': { x: 80, y: 20, z: 0 }
        };
        const pos = views[view] || views['interior'];
        camera.position.set(pos.x, pos.y, pos.z);
        camera.lookAt(10, 3, 10);
      };

      window.goBack = () => window.location.href = 'upload.html';
      window.downloadVisualization = () => alert('Download coming soon!');

      // Toggles
      document.getElementById('toggle-furniture').addEventListener('change', (e) => {
        furnitureGroup.visible = e.target.checked;
      });
      document.getElementById('toggle-walls').addEventListener('change', (e) => {
        wallsGroup.visible = e.target.checked;
      });
      document.getElementById('toggle-roof').addEventListener('change', (e) => {
        roofGroup.visible = e.target.checked;
      });
      document.getElementById('toggle-labels').addEventListener('change', (e) => {
        document.getElementById('labels-container').style.display = e.target.checked ? 'block' : 'none';
      });

      // Auto-rotate toggle
      const autoCheckbox = document.getElementById('toggle-auto-rotate');
      if (autoCheckbox) {
        controls.autoRotate = autoCheckbox.checked;
        autoCheckbox.addEventListener('change', (e) => { controls.autoRotate = e.target.checked; });
      }

      // Render and animate
      renderRooms();
      animate();
      window.setView('interior');

      // Hide loading screen
      setTimeout(() => {
        const loading = document.getElementById('loading-screen');
        if (loading) loading.style.display = 'none';
      }, 300);

      // Resize handler
      window.addEventListener('resize', () => {
        const w = window.innerWidth;
        const h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      });
    }

    // Wait for DOM
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initScene);
    } else {
      initScene();
    }
  </script>
</body>
</html>
