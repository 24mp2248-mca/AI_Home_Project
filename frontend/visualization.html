<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>3D House - Complete Structure | AI Home Planner</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: #0a0a0a;
      color: #ffffff;
      overflow: hidden;
      height: 100vh;
      font-family: 'Segoe UI', sans-serif;
    }

    #header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 70px;
      background: rgba(20, 20, 30, 0.6);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 30px;
      z-index: 1000;
      backdrop-filter: blur(20px);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .logo {
      font-size: 1.3rem;
      font-weight: 800;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .btn {
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      margin-left: 12px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-size: 0.95rem;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }

    .sidebar {
      position: fixed;
      left: 20px;
      top: 90px;
      width: 260px;
      max-height: calc(100vh - 110px);
      background: rgba(20, 20, 30, 0.6);
      border-radius: 16px;
      padding: 20px;
      overflow-y: auto;
      z-index: 100;
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .sidebar h3 {
      color: #ffffff;
      font-size: 1.05rem;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .control-group {
      margin-bottom: 18px;
    }

    .control-group label {
      display: flex;
      align-items: center;
      gap: 12px;
      color: #e0e0e0;
      font-size: 0.95rem;
      margin-bottom: 10px;
      cursor: pointer;
      user-select: none;
      padding: 8px;
      border-radius: 8px;
      transition: all 0.2s;
    }

    .control-group label:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #ffffff;
    }

    .control-group input[type="checkbox"] {
      accent-color: #667eea;
      width: 20px;
      height: 20px;
      cursor: pointer;
    }

    .view-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin: 18px 0;
    }

    .view-btn {
      padding: 12px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #ccc;
      border-radius: 10px;
      font-size: 0.9rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .view-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      transform: translateY(-2px);
    }

    .view-btn.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-color: transparent;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    .info-panel {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 18px;
      margin: 18px 0;
      color: white;
    }

    .info-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 12px;
      font-size: 0.95rem;
      align-items: center;
      color: #e0e0e0;
    }

    .info-item:last-child {
      margin-bottom: 0;
    }

    .info-item strong {
      font-weight: 800;
      font-size: 1.2rem;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      color: #fff;
    }

    .room-list {
      margin-top: 18px;
    }

    .room-list-title {
      color: #e0e0e0;
      font-size: 0.95rem;
      font-weight: 700;
      margin-bottom: 12px;
      display: block;
    }

    .room-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      margin-bottom: 6px;
      font-size: 0.9rem;
      color: #e0e0e0;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      transition: all 0.2s;
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    .room-item:hover {
      transform: translateX(4px);
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.1);
    }

    .room-color {
      width: 16px;
      height: 16px;
      border-radius: 4px;
      flex-shrink: 0;
      border: 2px solid rgba(255, 255, 255, 0.8);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }

    #canvas-container {
      position: fixed;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(180deg, #0a0a0a 0%, #1a1a2e 100%);
      /* Night Sky */
      z-index: 1;
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .room-label {
      position: fixed;
      background: rgba(0, 0, 0, 0.7);
      color: #ffffff;
      /* Force white text */
      padding: 4px 12px;
      border-radius: 12px;
      font-weight: 600;
      font-size: 11px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      pointer-events: none;
      transform: translate(-50%, -50%);
      z-index: 9999;
      /* Ensure on top of everything */
      white-space: nowrap;
      border: 1px solid rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(4px);
      text-transform: uppercase;
      letter-spacing: 1px;
      font-family: 'Open Sans', sans-serif;
    }

    .key-icon {
      display: inline-block;
      width: 24px;
      height: 24px;
      line-height: 24px;
      text-align: center;
      border: 1px solid #fff;
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.2);
      font-weight: bold;
      margin: 0 2px;
      font-size: 12px;
    }

    #walk-hud {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 15px;
      backdrop-filter: blur(4px);
    }

    #tour-hud {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 15px 25px;
      border-radius: 50px;
      display: none;
      z-index: 9999;
      align-items: center;
      gap: 15px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }

    .tour-btn {
      background: none;
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
      padding: 5px;
      transition: transform 0.2s;
    }

    .tour-btn:hover {
      transform: scale(1.2);
      color: #667eea;
    }

    .room-label.living {
      color: #667eea;
      border-color: #667eea;
      box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
    }

    .room-label.kitchen {
      color: #f59e0b;
      border-color: #f59e0b;
      box-shadow: 0 6px 16px rgba(245, 158, 11, 0.4);
    }

    .room-label.bedroom {
      color: #10b981;
      border-color: #10b981;
      box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4);
    }

    .room-label.bathroom {
      color: #3b82f6;
      border-color: #3b82f6;
      box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
    }

    .room-label.carport {
      color: #8b5cf6;
      border-color: #8b5cf6;
      box-shadow: 0 6px 16px rgba(139, 92, 246, 0.4);
    }

    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      z-index: 20000;
    }

    .spinner {
      width: 60px;
      height: 60px;
      border: 5px solid rgba(255, 255, 255, 0.2);
      border-top: 5px solid white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 25px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    .loading-content {
      text-align: center;
      color: white;
    }

    .loading-content h2 {
      font-size: 1.8rem;
      margin-bottom: 12px;
      font-weight: 800;
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    }

    .loading-content p {
      font-size: 1.1rem;
      opacity: 0.9;
    }
  </style>
</head>

<body>

  <div id="loading-screen" class="loading-screen">
    <div class="loading-content">
      <div class="spinner"></div>
      <h2>Building Your Dream Home</h2>
      <p>Creating stunning 3D architecture...</p>
    </div>
  </div>

  <div id="crosshair"
    style="position: fixed; top: 50%; left: 50%; width: 12px; height: 12px; background: rgba(255, 255, 255, 0.4); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 1001; display: none; border: 2px solid rgba(0,0,0,0.5); transition: all 0.2s ease;">
    <div style="width: 2px; height: 2px; background: white; margin: 3px auto;"></div>
  </div>

  <div id="walk-hud">
    <div style="margin-bottom:8px; font-weight:bold; border-bottom:1px solid rgba(255,255,255,0.3); padding-bottom:4px">
      Controls</div>
    <div style="margin-bottom:4px"><span class="key-icon">W</span><span class="key-icon">A</span><span
        class="key-icon">S</span><span class="key-icon">D</span> Move</div>
    <div style="margin-bottom:4px">üñ±Ô∏è Look Around</div>
    <div style="margin-bottom:4px">üñ±Ô∏è Click to Interact</div>
    <div style="font-size: 0.9em; color: #ccc;">[ESC] to Exit</div>
  </div>

  <div id="tour-hud" style="display: none;">
    <div id="tour-status" style="font-weight: bold; margin-right: 15px; color: #ffab91;">Tour Active</div>
    <button class="tour-btn" id="btn-pause" onclick="pauseTour()">‚è∏</button>
    <button class="tour-btn" id="btn-play" onclick="resumeTour()" style="display:none">‚ñ∂</button>
    <button class="tour-btn" onclick="stopTour()">‚èπ</button>
  </div>

  <div id="instructions"
    style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, rgba(30,30,30,0.95), rgba(10,10,10,0.95)); padding: 30px; color: white; border-radius: 16px; text-align: center; display: none; z-index: 2000; box-shadow: 0 10px 40px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.1); width: 400px;">
    <h2 style="margin-top:0; color: #667eea; font-weight: 800;">üö∂ Walk Mode Guide</h2>

    <div style="display: flex; justify-content: space-around; margin: 25px 0; text-align: center;">
      <div style="width: 45%;">
        <div style="font-size: 40px; margin-bottom: 10px;">üñ±Ô∏è</div>
        <strong style="display:block; margin-bottom: 5px; color: #ffab91;">YOUR EYES</strong>
        <p style="font-size: 12px; color: #ccc; margin:0;">Move Mouse to Look<br>Up, Down, Left, Right</p>
      </div>
      <div style="width: 1px; background: rgba(255,255,255,0.2);"></div>
      <div style="width: 45%;">
        <div style="font-size: 40px; margin-bottom: 10px;">‚å®Ô∏è</div>
        <strong style="display:block; margin-bottom: 5px; color: #80cbc4;">YOUR LEGS</strong>
        <p style="font-size: 12px; color: #ccc; margin:0;">
          <span class="key-icon">W</span> Forward<br>
          <span class="key-icon">S</span> Backward
        </p>
      </div>
    </div>

    <p style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 6px; font-size: 13px;">
      üí° <strong>Tip:</strong> Aim at doors and <strong>Click</strong> to open them!
    </p>

    <button onclick="startWalk()"
      style="margin-top: 20px; padding: 12px 30px; background: #667eea; border: none; color: white; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 16px; transition: transform 0.2s;">Let's
      Go! üöÄ</button>
  </div>

  <div id="header">
    <div class="logo">üè† AI Home Planner Pro</div>
    <div>
      <button class="btn btn-secondary" onclick="goBack()">‚Üê Back</button>
      <button class="btn btn-secondary" onclick="export3DModel()">üì¶ Export 3D</button>
      <button class="btn btn-primary" onclick="downloadVisualization()">üì∏ Screenshot</button>
    </div>
  </div>
  </div>

  <div class="sidebar">
    <h3>üé® Actions</h3>

    <button class="btn btn-primary" onclick="showInstructions()" style="width: 100%; margin: 0 0 10px 0;">üö∂ Walk
      Inside</button>
    <button class="btn btn-secondary" onclick="startTour()"
      style="width: 100%; margin: 0 0 10px 0; background: #8b5cf6; border:none;">üé¨ Start Auto Tour</button>
    <button class="btn btn-primary" onclick="window.location.href='cost_estimation.html'"
      style="width: 100%; margin: 0 0 20px 0; background: linear-gradient(135deg, #10b981 0%, #059669 100%); border:none;">üí∞
      Cost Estimate</button>

    <h3>üëÅÔ∏è Visibility</h3>
    <div class="control-group">
      <label><input type="checkbox" id="toggle-labels" checked> Room Labels</label>
      <label><input type="checkbox" id="toggle-furniture" checked> Furniture</label>
      <label><input type="checkbox" id="toggle-roof" checked> Roof</label>
      <label><input type="checkbox" id="toggle-windows" checked> Windows</label>
      <label><input type="checkbox" id="toggle-doors" checked> Doors</label>
    </div>

    <h3>üåç Environment</h3>
    <div class="control-group">
      <button class="btn btn-secondary" onclick="toggleTime()" id="btn-daynight"
        style="width: 100%; margin-bottom: 10px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.1);">üåô
        Toggle Day/Night</button>
      <label><input type="checkbox" id="toggle-auto-rotate"> Auto Rotate</label>
      <label style="flex-direction: column; align-items: flex-start; gap: 5px;">
        <span>üè† Exterior Paint</span>
        <input type="color" id="wall-color-picker" value="#f5f5dc"
          style="width: 100%; height: 35px; border: none; padding: 0; background: none;">
      </label>
    </div>

    <h3>üß† AI Vision</h3>
    <div class="control-group" style="text-align: center;">
      <p style="font-size: 0.8rem; color: #aaa; margin-bottom: 8px;">What the AI sees (Segmentation Mask)</p>
      <img id="ai-vision-debug" src="" alt="AI Vision Output"
        style="width: 100%; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); display: none;">
      <p id="ai-vision-status" style="font-size: 0.8rem; color: #aaa; margin-top: 5px;">No AI data found</p>
    </div>

    <h3 style="margin-top: 20px;">üì∑ Camera Views</h3>
    <div class="view-buttons">
      <button class="view-btn active" data-view="iso">3D View</button>
      <button class="view-btn" data-view="top">Top Down</button>
      <button class="view-btn" data-view="front">Entrance</button>
      <button class="view-btn" data-view="interior">Interior</button>
    </div>

    <div class="info-panel">
      <div class="info-item"><span>Rooms:</span><strong id="room-count">0</strong></div>
      <div class="info-item"><span>Total Area:</span><strong id="total-area">0</strong> m¬≤</div>

    </div>

    <div class="room-list">
      <span class="room-list-title">üìã Room Details</span>
      <div id="room-list"></div>
    </div>
  </div>

  <div id="canvas-container"></div>
  <div id="labels-container"></div>

  <script src="chatbot.js"></script>
  <script>
    // Init Chatbot
    document.addEventListener('DOMContentLoaded', () => {
      new AIChatbot({
        context: {
          page: 'visualization',
          total_area: 200 // Default, updates dynamically in JS
        }
      });
    });

    // Listen for AI Actions (Color Change, Gardening, etc)
    window.addEventListener('ai-action', (e) => {
      const action = e.detail;
      console.log("AI Command:", action);

      // 1. CHANGE COLOR
      if (action.type === 'change_color') {
        if (action.target === 'walls' && window.exteriorWallMat) {
          window.exteriorWallMat.color.set(action.value);
        }
        // Update Picker UI
        const picker = document.getElementById('wall-color-picker');
        if (picker) picker.value = action.value;
      }

      // 2. ADD FEATURE (e.g. Garden)
      else if (action.type === 'add_feature' && action.value === 'garden') {
        createGarden();
      }

      // 3. ADD FURNITURE
      else if (action.type === 'add_furniture') {
        createFurniture(action.value);
      }
    });

    function createFurniture(type) {
      if (!window.scene) return;
      const color = 0x8d6e63; // generic wood/fabric
      let geometry;

      // Simple placeholder geometries
      if (type === 'table') geometry = new THREE.BoxGeometry(2, 0.8, 1); // 2m x 0.8m table
      else if (type === 'sofa') geometry = new THREE.BoxGeometry(2, 0.8, 0.8);
      else if (type === 'bed') geometry = new THREE.BoxGeometry(1.8, 0.6, 2);
      else geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5); // chair/misc

      const material = new THREE.MeshStandardMaterial({ color: color });
      const mesh = new THREE.Mesh(geometry, material);

      // Place in front of camera or center
      mesh.position.set(50, 2, 50); // Default center for now
      mesh.castShadow = true;

      window.scene.add(mesh);
      console.log(`Added ${type} at (50, 2, 50)`);
    }

    function createGarden() {
      if (!window.scene) return;
      console.log("Creating Realistic Garden...");

      // Remove old garden if exists
      const oldGarden = window.scene.getObjectByName("GardenGroup");
      if (oldGarden) window.scene.remove(oldGarden);

      const gardenGroup = new THREE.Group();
      gardenGroup.name = "GardenGroup";
      window.scene.add(gardenGroup);

      // --- 1. TREES (Trunk + Foliage) ---
      const trunkGeo = new THREE.CylinderGeometry(0.4, 0.6, 2, 6);
      const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.9 }); // Wood

      const leavesGeo = new THREE.ConeGeometry(2.5, 6, 8);
      const leavesMat = new THREE.MeshStandardMaterial({ color: 0x2e7d32, roughness: 0.8 }); // Green

      for (let i = 0; i < 15; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = 25 + Math.random() * 20; // Further out
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;

        const treeGroup = new THREE.Group();
        treeGroup.position.set(x, 0, z);

        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = 1;
        trunk.castShadow = true;

        const leaves = new THREE.Mesh(leavesGeo, leavesMat);
        leaves.position.y = 4; // On top of trunk
        leaves.castShadow = true;

        treeGroup.add(trunk);
        treeGroup.add(leaves);

        // Random Scale
        const scale = 0.8 + Math.random() * 0.5;
        treeGroup.scale.setScalar(scale);

        gardenGroup.add(treeGroup);
      }

      // --- 2. FLOWER BEDS ---
      const bedGeo = new THREE.CircleGeometry(1.5, 12);
      const bedMat = new THREE.MeshStandardMaterial({ color: 0x3e2723 }); // Soil

      const petalGeo = new THREE.SphereGeometry(0.2, 4, 4);
      const flowerCols = [0xe91e63, 0xffeb3b, 0x9c27b0, 0xff5722];

      for (let i = 0; i < 10; i++) {
        // Closer to house
        const angle = Math.random() * Math.PI * 2;
        const radius = 10 + Math.random() * 5;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;

        const bed = new THREE.Mesh(bedGeo, bedMat);
        bed.rotation.x = -Math.PI / 2;
        bed.position.set(x, 0.05, z);
        gardenGroup.add(bed);

        // Add flowers on the bed
        for (let j = 0; j < 8; j++) {
          const fMat = new THREE.MeshBasicMaterial({ color: flowerCols[Math.floor(Math.random() * flowerCols.length)] });
          const flower = new THREE.Mesh(petalGeo, fMat);
          flower.position.set(
            x + (Math.random() - 0.5) * 2,
            0.3,
            z + (Math.random() - 0.5) * 2
          );
          gardenGroup.add(flower);
        }
      }

      // --- 3. STONE PATHWAY ---
      // Simple steps leading from (0,0) outwards
      const stoneGeo = new THREE.BoxGeometry(1.5, 0.1, 1);
      const stoneMat = new THREE.MeshStandardMaterial({ color: 0x9e9e9e });

      for (let i = 1; i < 10; i++) {
        const stone = new THREE.Mesh(stoneGeo, stoneMat);
        stone.position.set(0, 0.05, 5 + (i * 1.5)); // Leading forward Z
        stone.castShadow = true;
        gardenGroup.add(stone);
      }
    }

  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const scripts = [
      'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js',
      'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js',
      'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js',
      'https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js'
    ];

    let loadedCount = 0;
    function checkScripts() {
      loadedCount++;
      if (loadedCount >= scripts.length) initScene();
    }

    scripts.forEach(src => {
      const s = document.createElement('script');
      s.src = src;
      s.onload = checkScripts;
      document.head.appendChild(s);
    });

    function initScene() {
      // ... (scene setup code remains same) ...
      // We need to access exteriorWallMat globally or inside builds

      const container = document.getElementById('canvas-container');
      let w = window.innerWidth;
      let h = window.innerHeight;

      const scene = new THREE.Scene();
      window.scene = scene; // Expose globally for AI actions
      scene.background = new THREE.Color(0xa8d5ff);
      scene.fog = new THREE.Fog(0xa8d5ff, 80, 250);

      const camera = new THREE.PerspectiveCamera(55, w / h, 0.1, 1000);
      camera.position.set(50, 40, 50);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
      renderer.setSize(w, h);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;
      container.appendChild(renderer.domElement);

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.minDistance = 15;
      controls.maxDistance = 120;
      controls.maxPolarAngle = Math.PI / 2.1;
      controls.target.set(0, 0, 0);

      // --- LIGHTING ---
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
      dirLight.position.set(50, 80, 50);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 4096;
      dirLight.shadow.mapSize.height = 4096;
      dirLight.shadow.camera.near = 0.5;
      dirLight.shadow.camera.far = 200;
      dirLight.shadow.camera.left = -50;
      dirLight.shadow.camera.right = 50;
      dirLight.shadow.camera.top = 50;
      dirLight.shadow.camera.bottom = -50;
      dirLight.shadow.bias = -0.0005;
      scene.add(dirLight);

      const moonLight = new THREE.DirectionalLight(0x8899ff, 0.0); // Initially off
      moonLight.position.set(-50, 80, -50);
      moonLight.castShadow = true; // Moon shadows
      scene.add(moonLight);

      const fillLight = new THREE.DirectionalLight(0xffeedd, 0.3);
      fillLight.position.set(-20, 20, -20);
      scene.add(fillLight);

      // Global list for interior lights
      window.interiorLights = [];

      // Environment & Ground
      const groundGeo = new THREE.PlaneGeometry(300, 300);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x558b2f, // Richer grass green
        roughness: 1,
        metalness: 0
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Grid (make it subtle)
      const gridHelper = new THREE.GridHelper(100, 50, 0xffffff, 0xffffff);
      gridHelper.position.y = 0.05;
      gridHelper.material.opacity = 0.15;
      gridHelper.material.transparent = true;
      scene.add(gridHelper);

      const houseGroup = new THREE.Group();
      const furnitureGroup = new THREE.Group();
      const roofGroup = new THREE.Group();
      const doorsGroup = new THREE.Group();
      const windowsGroup = new THREE.Group();
      const environmentGroup = new THREE.Group(); // New group for trees, fence

      scene.add(houseGroup);
      scene.add(furnitureGroup);
      scene.add(roofGroup);
      scene.add(doorsGroup);
      scene.add(windowsGroup);
      scene.add(environmentGroup);

      // --- MATERIALS ---
      // Exterior Walls: Warm, welcoming colors
      const exteriorWallMat = new THREE.MeshStandardMaterial({
        color: 0xf5f5dc, // Beige/Cream
        roughness: 0.6,
        metalness: 0.1
      });
      // Expose globally for AI actions
      window.exteriorWallMat = exteriorWallMat;

      // Interior Walls: Neutral off-white
      const interiorWallMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.8,
        metalness: 0.0
      });

      // Roof: Darker, modern tile color
      const roofMat = new THREE.MeshStandardMaterial({
        color: 0x3e2723, // Dark Brown
        roughness: 0.7,
        metalness: 0.1
      });

      const doorMat = new THREE.MeshStandardMaterial({
        color: 0x5d4037, // Wood
        roughness: 0.6,
        metalness: 0.1
      });

      const windowMat = new THREE.MeshStandardMaterial({
        color: 0x81d4fa,
        transparent: true,
        opacity: 0.4,
        roughness: 0.1,
        metalness: 0.8,
        envMapIntensity: 1.0
      });

      const roomColors = {
        'living': 0xe8eaf6, // Soft Blue-Grey
        'kitchen': 0xfff3e0, // Soft Orange
        'bedroom': 0xe8f5e9, // Soft Green
        'bathroom': 0xe0f7fa, // Cyan tint
        'carport': 0xeeeeee, // Concrete
        'entrance': 0xffecb3, // Warm tint
        'dining': 0xfbe9e7, // Warm Rose
        'default': 0xf5f5f5  // White Sand
      };

      // Handle Color Picker
      document.getElementById('wall-color-picker').addEventListener('input', (e) => {
        exteriorWallMat.color.set(e.target.value);
      });

      let houseLayout = {
        totalWidth: 24,
        totalDepth: 20,
        wallHeight: 3.5, // Taller walls
        wallThickness: 0.2, // Thinner walls relative to scale
        rooms: []
      };

      try {
        let stored = sessionStorage.getItem('roomData') || localStorage.getItem('roomData');
        if (stored && stored !== '[]' && stored !== 'undefined' && stored !== 'null') {
          const parsedRooms = JSON.parse(stored);
          if (Array.isArray(parsedRooms) && parsedRooms.length > 0) {
            houseLayout.rooms = convertToLayout(parsedRooms);
          }
        } else {
          // Demo data for preview
          houseLayout.rooms = [
            { type: "Living Room", x: 0, z: 0, width: 12, depth: 10 },
            { type: "Kitchen", x: 12, z: 0, width: 12, depth: 10 },
            { type: "Bedroom", x: 0, z: 10, width: 12, depth: 10 },
            { type: "Bathroom", x: 12, z: 10, width: 7, depth: 10 },
            { type: "Carport", x: 19, z: 10, width: 5, depth: 10 }
          ];
        }
      } catch (e) {
        console.error('Storage error:', e);
      }

      // --- LOAD AI VISION IMAGE ---
      try {
        const pInfoStr = sessionStorage.getItem('projectInfo') || localStorage.getItem('projectInfo');
        if (pInfoStr) {
          const pInfo = JSON.parse(pInfoStr);
          if (pInfo.processed_image_url) {
            const imgEl = document.getElementById('ai-vision-debug');
            const statusEl = document.getElementById('ai-vision-status');
            // Check if URL is absolute or relative. Backend returns /processed/filename
            // Needs backend base URL if on different port, but here likely same origin or proxy
            // Backend is 8000. Frontend static? Usually main.py serves static.
            // main.py mounts /static. 
            // Wait, main.py processes upload and returns URL relative to /processed/...
            // The file response endpoint is @app.get('/processed/{fname}').
            // If we access simple static HTML file, we might be on file:// or port 5500.
            // Assuming localhost:8000 for full stack.
            // If separate, need http://127.0.0.1:8000 prefix.

            // Let's assume absolute path if starts with /, else add prefix
            let finalUrl = pInfo.processed_image_url;
            if (!finalUrl.startsWith('http')) {
              finalUrl = 'http://127.0.0.1:8000' + finalUrl;
            }

            imgEl.src = finalUrl;
            imgEl.style.display = 'block';
            statusEl.textContent = 'Segmentation Mask (U-Net)';
            statusEl.style.color = '#66bb6a'; // Green
          }
        }
      } catch (e) {
        console.log("No AI image info found", e);
      }

      function convertToLayout(rooms) {
        const layout = [];
        const SCALE = 3.5; // Massive scale for spaciousness

        rooms.forEach((room, i) => {
          let width, depth, x, z, type;

          if (room.width_m !== undefined) {
            width = room.width_m;
            depth = room.length_m;
            x = room.x_m;
            z = room.y_m;
            type = room.type || `Room ${room.room_id || i + 1}`;
          } else if (room.dimensions) {
            width = room.dimensions.length;
            depth = room.dimensions.width;
            x = room.position ? room.position.x : 0;
            z = room.position ? room.position.y : 0;
            type = room.type;
          }

          if (width && depth) {
            layout.push({
              type: type || `Room ${i + 1}`,
              x: (x || 0) * SCALE,
              z: (z || 0) * SCALE,
              width: width * SCALE,
              depth: depth * SCALE
            });
          }
        });

        if (layout.length > 0) {
          let maxX = 0, maxZ = 0;
          layout.forEach(r => {
            maxX = Math.max(maxX, r.x + r.width);
            maxZ = Math.max(maxZ, r.z + r.depth);
          });
          houseLayout.totalWidth = maxX;
          houseLayout.totalDepth = maxZ;
        }

        return layout;
      }

      function getRoomColor(roomType) {
        const type = roomType.toLowerCase();
        for (let key in roomColors) {
          if (type.includes(key)) return roomColors[key];
        }
        return roomColors.default;
      }

      let isNight = false;
      window.toggleTime = function () {
        isNight = !isNight;

        if (isNight) {
          // Switch to Night
          // Sky: Dark Blue
          new TWEEN.Tween(scene.background)
            .to({ r: 0.05, g: 0.08, b: 0.15 }, 2000)
            .start();
          new TWEEN.Tween(scene.fog.color)
            .to({ r: 0.05, g: 0.08, b: 0.15 }, 2000)
            .start();

          // Sun Down (dimmer, but not 0 so we still see shadows faintly or rely on moon)
          // Actually, disable sun shadow? No, just reduce intensity.
          // Main Directional Light (Sun) -> become weak
          // We need access to lights. They are local scope in initScene. 
          // Fix: Make them global/accessible or find them in scene.
          // Easier: Find by type in scene. 
          // scene.children...
        } else {
          // Switch to Day
          new TWEEN.Tween(scene.background)
            .to({ r: 0.66, g: 0.84, b: 1.0 }, 2000)
            .start();
          new TWEEN.Tween(scene.fog.color)
            .to({ r: 0.66, g: 0.84, b: 1.0 }, 2000)
            .start();
        }

        // Helper to tween a light property
        const tweenLight = (light, intensity, colorHex) => {
          if (!light) return;
          new TWEEN.Tween(light)
            .to({ intensity: intensity }, 2000)
            .start();
          if (colorHex !== undefined) {
            const c = new THREE.Color(colorHex);
            new TWEEN.Tween(light.color)
              .to({ r: c.r, g: c.g, b: c.b }, 2000)
              .start();
          }
        };

        // Find Lights in Scene (since variables like dirLight are local to initScene)
        // We know their initial positions/types.
        const lights = scene.children.filter(o => o.isLight);
        const sun = lights.find(l => l.isDirectionalLight && l.position.x > 0); // Sun at 50,80,50
        const moon = lights.find(l => l.isDirectionalLight && l.position.x < -40); // Moon at -50,80,-50
        const ambient = lights.find(l => l.isAmbientLight);

        if (isNight) {
          tweenLight(sun, 0.0);
          tweenLight(moon, 0.4);
          tweenLight(ambient, 0.1); // Dark ambient
          // Interior Lights UP
          window.interiorLights.forEach(l => tweenLight(l, 1.5));
        } else {
          tweenLight(sun, 1.2);
          tweenLight(moon, 0.0);
          tweenLight(ambient, 0.6);
          // Interior Lights Normal
          window.interiorLights.forEach(l => tweenLight(l, 0.5));
        }
      };

      function buildHouse() {
        houseGroup.clear();
        furnitureGroup.clear();
        roofGroup.clear();
        doorsGroup.clear();
        windowsGroup.clear();

        window.interiorLights = []; // Reset lights list
        environmentGroup.clear(); // Clear environment

        const hh = houseLayout.wallHeight;
        const wt = houseLayout.wallThickness; // 0.25

        // Calculate Bounds
        let maxX = 0, maxZ = 0;
        houseLayout.rooms.forEach(room => {
          maxX = Math.max(maxX, room.x + room.width);
          maxZ = Math.max(maxZ, room.z + room.depth);
        });

        const centerX = maxX / 2;
        const centerZ = maxZ / 2;

        // --- COMPOUND & ENVIRONMENT ---
        buildCompound(centerX, centerZ, maxX, maxZ);

        // --- FOUNDATION ---
        const foundationGeo = new THREE.BoxGeometry(maxX + 0.4, 0.4, maxZ + 0.4);
        const foundationMat = new THREE.MeshStandardMaterial({
          color: 0x9e9e9e, // Concrete
          roughness: 0.9,
          metalness: 0.1
        });
        const foundation = new THREE.Mesh(foundationGeo, foundationMat);
        foundation.position.set(centerX, 0.2, centerZ);
        foundation.receiveShadow = true;
        foundation.castShadow = true;
        houseGroup.add(foundation);

        // --- EXTERIOR WALLS (SHELL) ---
        // We build the outer shell separate from interior walls for better coloring
        const shellThickness = wt;

        // Front (Door side usually)
        const frontWall = new THREE.Mesh(new THREE.BoxGeometry(maxX, hh, shellThickness), exteriorWallMat);
        frontWall.position.set(centerX, hh / 2, -shellThickness / 2);
        frontWall.castShadow = true;
        frontWall.receiveShadow = true;
        houseGroup.add(frontWall);

        // Back
        const backWall = new THREE.Mesh(new THREE.BoxGeometry(maxX, hh, shellThickness), exteriorWallMat);
        backWall.position.set(centerX, hh / 2, maxZ - shellThickness / 2);
        backWall.castShadow = true;
        houseGroup.add(backWall);

        // Left
        const leftWall = new THREE.Mesh(new THREE.BoxGeometry(shellThickness, hh, maxZ), exteriorWallMat);
        leftWall.position.set(-shellThickness / 2, hh / 2, centerZ);
        leftWall.castShadow = true;
        houseGroup.add(leftWall);

        // Right
        const rightWall = new THREE.Mesh(new THREE.BoxGeometry(shellThickness, hh, maxZ), exteriorWallMat);
        rightWall.position.set(maxX - shellThickness / 2, hh / 2, centerZ);
        rightWall.castShadow = true;
        houseGroup.add(rightWall);

        // --- ROOF (HIP STYLE) ---
        // A simple Hip roof primitive
        const roofHeight = 2.5;
        const overhang = 0.8;
        const roofW = maxX + overhang * 2;
        const roofD = maxZ + overhang * 2;

        // Create a pyramid-like shape for the roof
        // We can use a 4-sided cylinder (pyramid) but scaling it is tricky for rects.
        // Better: PrismGeometry? Or manual geometry.
        // Let's use a Cylinder 4 segments for a basic pyramid, scaled.
        const roofGeo = new THREE.ConeGeometry(1, roofHeight, 4, 1, true); // Open base
        const roof = new THREE.Mesh(roofGeo, roofMat);
        roof.rotation.y = Math.PI / 4; // Align sides
        // Scale to fit rect
        // The diameter of cone is 2 (radius 1). 
        // We need 'diameter' to match Diagonal? No. 
        // 4-sided cone at rotation PI/4 has width = sqrt(2). 
        // Let's scale x and z independently.
        const scaleX = roofW * 0.75; // Approx fix for cone rotation
        const scaleZ = roofD * 0.75;
        // Actually, let's use a specialized roof function for better results.
        buildHipRoof(centerX, hh, centerZ, roofW, roofD, roofHeight);


        // --- INTERNAL ROOMS ---
        houseLayout.rooms.forEach((room, idx) => {
          const rx = room.x + room.width / 2;
          const rz = room.z + room.depth / 2;

          // Floor
          const floorColor = getRoomColor(room.type);
          const roomFloorGeo = new THREE.BoxGeometry(room.width - 0.1, 0.05, room.depth - 0.1);
          const roomFloorMat = new THREE.MeshStandardMaterial({
            color: floorColor,
            roughness: 0.8,
            metalness: 0.1
          });
          const roomFloor = new THREE.Mesh(roomFloorGeo, roomFloorMat);
          roomFloor.position.set(rx, 0.45, rz); // Slightly above foundation
          roomFloor.receiveShadow = true;
          houseGroup.add(roomFloor);

          // Internal Walls (Partitions)
          // We check if the wall is shared with exterior or another room.
          // For simplicity, we draw internal walls at the right and bottom of each room
          // UNLESS it's the house boundary.

          const isRightEdge = Math.abs((room.x + room.width) - maxX) < 0.1;
          const isBottomEdge = Math.abs((room.z + room.depth) - maxZ) < 0.1;

          if (!isRightEdge) {
            const iWall = new THREE.Mesh(new THREE.BoxGeometry(wt, hh, room.depth), interiorWallMat);
            iWall.position.set(room.x + room.width, hh / 2, rz);
            iWall.castShadow = true;
            iWall.receiveShadow = true;
            houseGroup.add(iWall);

            // Internal Door?
            addDoor(room.x + room.width, 1.1, rz, false);
          }

          if (!isBottomEdge) {
            const iWall = new THREE.Mesh(new THREE.BoxGeometry(room.width, hh, wt), interiorWallMat);
            iWall.position.set(rx, hh / 2, room.z + room.depth);
            iWall.castShadow = true;
            houseGroup.add(iWall);
            // Internal Door?
            addDoor(rx, 1.1, room.z + room.depth, true);
          }

          // Furniture
          addFurniture(room, furnitureGroup);

          // External Windows
          // Check if room touches exterior
          if (room.z < 0.5) addWindow(rx, 1.8, 0, true); // Front
          if (Math.abs((room.x + room.width) - maxX) < 0.5) addWindow(maxX, 1.8, rz, false); // Right
          if (room.x < 0.5) addWindow(0, 1.8, rz, false); // Left
          // Back windows maybe?
        });

        // --- ENTRANCE PATH & DOOR ---
        // Find best entrance spot
        let entranceRoom = houseLayout.rooms.find(r => r.type.toLowerCase().includes('entrance')) ||
          houseLayout.rooms.find(r => r.type.toLowerCase().includes('living')) ||
          houseLayout.rooms[0];

        if (entranceRoom) {
          const doorX = entranceRoom.x + entranceRoom.width / 2;

          // Main Door
          const mainDoor = new THREE.Mesh(
            new THREE.BoxGeometry(1.6, 2.4, wt + 0.1),
            doorMat
          );
          mainDoor.position.set(doorX, 1.2, -wt / 2);
          mainDoor.castShadow = true;
          doorsGroup.add(mainDoor);


          // Handle
          const handle = new THREE.Mesh(new THREE.SphereGeometry(0.08), new THREE.MeshStandardMaterial({ color: 0xffd700 }));
          handle.position.set(doorX + 0.6, 1.2, -wt / 2 + 0.1);
          doorsGroup.add(handle);

          // Porch
          const porchGeo = new THREE.BoxGeometry(2.5, 0.2, 1.5);
          const porch = new THREE.Mesh(porchGeo, new THREE.MeshStandardMaterial({ color: 0x9e9e9e }));
          porch.position.set(doorX, 0.1, -1.0);
          porch.receiveShadow = true;
          houseGroup.add(porch);

          // Path
          const pathGeo = new THREE.BoxGeometry(2, 0.05, 15);
          const pathMat = new THREE.MeshStandardMaterial({ color: 0xd7ccc8 }); // Stone path
          const path = new THREE.Mesh(pathGeo, pathMat);
          path.position.set(doorX, 0.03, -8); // Extend out
          path.receiveShadow = true;
          environmentGroup.add(path);
        }

        updateUI();
      }

      function buildCompound(cx, cz, houseW, houseD) {
        const padding = 8; // Space around house
        const fenceW = houseW + padding * 2;
        const fenceD = houseD + padding * 2;
        const boundaryColor = 0x8d6e63;

        // Fence Wall
        const fenceH = 1.2;
        const fenceThick = 0.2;
        const fenceMat = new THREE.MeshStandardMaterial({ color: 0xffccbc, roughness: 0.8 });

        // Back
        const f1 = new THREE.Mesh(new THREE.BoxGeometry(fenceW, fenceH, fenceThick), fenceMat);
        f1.position.set(cx, fenceH / 2, cz + houseD / 2 + padding);
        f1.castShadow = true;
        environmentGroup.add(f1);

        // Front (with gap for gate)
        const f2a = new THREE.Mesh(new THREE.BoxGeometry(fenceW / 2 - 2, fenceH, fenceThick), fenceMat);
        f2a.position.set(cx - fenceW / 4 - 1, fenceH / 2, cz - houseD / 2 - padding);
        environmentGroup.add(f2a);

        const f2b = new THREE.Mesh(new THREE.BoxGeometry(fenceW / 2 - 2, fenceH, fenceThick), fenceMat);
        f2b.position.set(cx + fenceW / 4 + 1, fenceH / 2, cz - houseD / 2 - padding);
        environmentGroup.add(f2b);

        // Left
        const f3 = new THREE.Mesh(new THREE.BoxGeometry(fenceThick, fenceH, fenceD), fenceMat);
        f3.position.set(cx - houseW / 2 - padding, fenceH / 2, cz);
        f3.castShadow = true;
        environmentGroup.add(f3);

        // Right
        const f4 = new THREE.Mesh(new THREE.BoxGeometry(fenceThick, fenceH, fenceD), fenceMat);
        f4.position.set(cx + houseW / 2 + padding, fenceH / 2, cz);
        f4.castShadow = true;
        environmentGroup.add(f4);

        // Trees
        addVegetation(cx - houseW / 2 - 4, cz - houseD / 2 - 4);
        addVegetation(cx + houseW / 2 + 4, cz - houseD / 2 - 4);
        addVegetation(cx - houseW / 2 - 4, cz + houseD / 2 + 4);
        addVegetation(cx + houseW / 2 + 4, cz + houseD / 2 + 4);
      }

      function addVegetation(x, z) {
        // Simple Tree
        const trunkGeo = new THREE.CylinderGeometry(0.3, 0.4, 1.5, 8);
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.set(x, 0.75, z);
        trunk.castShadow = true;
        environmentGroup.add(trunk);

        const leavesGeo = new THREE.DodecahedronGeometry(1.5);
        const leavesMat = new THREE.MeshStandardMaterial({ color: 0x43a047 });
        const leaves = new THREE.Mesh(leavesGeo, leavesMat);
        leaves.position.set(x, 2.2, z);
        leaves.castShadow = true;
        environmentGroup.add(leaves);
      }

      function buildHipRoof(cx, y, cz, w, d, h) {
        // Custom Hip Roof Geometry is complex to build perfectly with primitives.
        // Let's use a prism (Gable) for now as it's cleaner than a distorted cone.
        // Or a 4-sided pyramid for a true Hip.

        const geometry = new THREE.ConeGeometry(1, h, 4, 1, true);
        const mesh = new THREE.Mesh(geometry, roofMat);

        // The cone base is rotated 45deg. 
        // We need to scale it to match w and d.
        // But a cone comes to a point. A hip roof usually has a ridge line if not square.
        // FOR SIMPLICITY: Gable Roof (Prism) is more "House-like" for non-squares.

        // Switch to Gable (Prism)
        mesh.geometry = new THREE.CylinderGeometry(0, 1, d, 4, 1, false);
        // Rotated to lay along Z?
        mesh.rotation.z = Math.PI / 2;
        mesh.rotation.y = Math.PI / 4; // This makes it a pyramid.

        // Let's just use a Prism (Extruded Triangle)
        const shape = new THREE.Shape();
        shape.moveTo(-w / 2, 0);
        shape.lineTo(0, h);
        shape.lineTo(w / 2, 0);
        shape.lineTo(-w / 2, 0);

        const extrudeSettings = {
          steps: 1,
          depth: d,
          bevelEnabled: false
        };

        const roofGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        const roofObj = new THREE.Mesh(roofGeo, roofMat);
        // Extrudes along Z, Center is at 0,0 usually but Shape starts at origin.
        // Move to center
        roofObj.position.set(cx, y, cz - d / 2);
        roofObj.castShadow = true;
        roofGroup.add(roofObj);

        // Add Overhang borders?
        // For now, this is sufficient.
      }

      function addDoor(x, y, z, rotate) {
        const door = new THREE.Mesh(new THREE.BoxGeometry(1.0, 2.2, 0.1), doorMat);
        door.position.set(x, y, z);
        if (rotate) door.rotation.y = Math.PI / 2;
        doorsGroup.add(door);
      }

      function addWindow(x, y, z, rotate) {
        const win = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.4, 0.1), windowMat);
        win.position.set(x, y, z);
        if (rotate) win.rotation.y = Math.PI / 2;

        const frame = new THREE.Mesh(new THREE.BoxGeometry(1.6, 1.5, 0.05), new THREE.MeshStandardMaterial({ color: 0xffffff }));
        frame.position.set(x, y, z);
        if (rotate) frame.rotation.y = Math.PI / 2;

        windowsGroup.add(win);
        windowsGroup.add(frame);
      }

      window.updateWallColor = function (color) {
        if (exteriorWallMat) {
          exteriorWallMat.color.set(color);
        }
      }

      function addFurniture(room, group) {
        const type = room.type.toLowerCase();
        const cx = room.x + room.width / 2;
        const cz = room.z + room.depth / 2;
        const isRotated = room.width < room.depth;

        // Add Interior Light (Warm Glow)
        const bulb = new THREE.PointLight(0xffaa00, 0.5, 12); // Incr range
        bulb.position.set(cx, 2.5, cz);
        bulb.castShadow = true; // Interior shadows!
        bulb.shadow.bias = -0.0001;
        group.add(bulb);
        window.interiorLights.push(bulb);

        // Rug (Common to most rooms)
        if (!type.includes('bathroom') && !type.includes('kitchen') && !type.includes('default')) {
          const rugGeo = new THREE.PlaneGeometry(room.width * 0.6, room.depth * 0.6);
          const rugMat = new THREE.MeshStandardMaterial({ color: 0xe0e0e0, roughness: 1.0 });
          const rug = new THREE.Mesh(rugGeo, rugMat);
          rug.rotation.x = -Math.PI / 2;
          rug.position.set(cx, 0.08, cz);
          rug.receiveShadow = true;
          group.add(rug);
        }

        if (type.includes('living')) {
          // Sofa
          const sofaWidth = 2.8;
          const sofaDepth = 1.0;
          const sofa = new THREE.Mesh(
            new THREE.BoxGeometry(sofaWidth, 0.9, sofaDepth),
            new THREE.MeshStandardMaterial({ color: 0x546e7a, roughness: 0.8 })
          );
          sofa.position.set(cx, 0.45, cz - 1.5);
          sofa.castShadow = true;
          group.add(sofa);

          // TV Stand
          const tvStand = new THREE.Mesh(
            new THREE.BoxGeometry(2.2, 0.6, 0.5),
            new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.6 })
          );
          tvStand.position.set(cx, 0.3, cz + 2.0);
          tvStand.castShadow = true;
          group.add(tvStand);

          // TV Screen
          const tv = new THREE.Mesh(
            new THREE.BoxGeometry(2.0, 1.2, 0.05),
            new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.8, roughness: 0.2 })
          );
          tv.position.set(cx, 1.0, cz + 2.0);
          tv.castShadow = true;
          group.add(tv);

          // Floor Lamp
          const lampPole = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 2.5),
            new THREE.MeshStandardMaterial({ color: 0x212121 })
          );
          lampPole.position.set(cx - 2.5, 1.25, cz - 1.5);
          group.add(lampPole);

          const lampShade = new THREE.Mesh(
            new THREE.ConeGeometry(0.6, 0.5, 32, 1, true),
            new THREE.MeshStandardMaterial({ color: 0xffecb3, transparent: true, opacity: 0.9, side: THREE.DoubleSide })
          );
          lampShade.position.set(cx - 2.5, 2.3, cz - 1.5);
          group.add(lampShade);

          // Plant
          const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.2, 0.4), new THREE.MeshStandardMaterial({ color: 0xffffff }));
          pot.position.set(cx + 2.5, 0.2, cz - 1.5);
          pot.castShadow = true;
          group.add(pot);

          const bush = new THREE.Mesh(new THREE.DodecahedronGeometry(0.4), new THREE.MeshStandardMaterial({ color: 0x43a047 }));
          bush.position.set(cx + 2.5, 0.5, cz - 1.5);
          bush.castShadow = true;
          group.add(bush);

        } else if (type.includes('kitchen')) {
          // Counter L-shape
          const counterLen = room.width * 0.8;
          const counterDepth = 0.8;

          const counter1 = new THREE.Mesh(
            new THREE.BoxGeometry(counterLen, 1, counterDepth),
            new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 })
          );
          counter1.position.set(cx, 0.5, cz - room.depth / 2 + 0.6);
          counter1.castShadow = true;
          group.add(counter1);

          // Fridge
          const fridge = new THREE.Mesh(
            new THREE.BoxGeometry(0.9, 2.1, 0.9),
            new THREE.MeshStandardMaterial({ color: 0xe0e0e0, metalness: 0.6, roughness: 0.2 })
          );
          fridge.position.set(cx - counterLen / 2 - 0.6, 1.05, cz - room.depth / 2 + 0.6);
          fridge.castShadow = true;
          group.add(fridge);

          // Upper Cabinets
          const cabinet = new THREE.Mesh(
            new THREE.BoxGeometry(counterLen, 0.8, 0.4),
            new THREE.MeshStandardMaterial({ color: 0xd7ccc8 })
          );
          cabinet.position.set(cx, 2.2, cz - room.depth / 2 + 0.6);
          cabinet.castShadow = true;
          group.add(cabinet);

        } else if (type.includes('bedroom')) {
          // Large Bed
          const bedW = 2.0;
          const bedL = 2.2;
          const bed = new THREE.Mesh(
            new THREE.BoxGeometry(bedW, 0.6, bedL),
            new THREE.MeshStandardMaterial({ color: 0x3949ab, roughness: 0.7 }) // Indigo sheets
          );
          bed.position.set(cx, 0.3, cz);
          bed.castShadow = true;
          group.add(bed);

          // Pillows
          const pillow = new THREE.Mesh(
            new THREE.BoxGeometry(0.7, 0.15, 0.4),
            new THREE.MeshStandardMaterial({ color: 0xffffff })
          );
          pillow.position.set(cx - 0.5, 0.65, cz - 0.8);
          group.add(pillow);
          const pillow2 = pillow.clone();
          pillow2.position.set(cx + 0.5, 0.65, cz - 0.8);
          group.add(pillow2);

          // Wardrobe
          const wardrobe = new THREE.Mesh(
            new THREE.BoxGeometry(1.5, 2.4, 0.6),
            new THREE.MeshStandardMaterial({ color: 0x5d4037 }) // Dark wood
          );
          wardrobe.position.set(cx - room.width / 2 + 0.5, 1.2, cz);
          wardrobe.castShadow = true;
          group.add(wardrobe);

        } else if (type.includes('bathroom')) {
          // Shower Stall
          const shower = new THREE.Mesh(
            new THREE.BoxGeometry(1.2, 2.2, 1.2),
            new THREE.MeshStandardMaterial({ color: 0x81d4fa, transparent: true, opacity: 0.3 })
          );
          shower.position.set(cx - room.width / 2 + 0.8, 1.1, cz - room.depth / 2 + 0.8);
          group.add(shower);

          // Vanity
          const vanity = new THREE.Mesh(
            new THREE.BoxGeometry(1.0, 0.8, 0.6),
            new THREE.MeshStandardMaterial({ color: 0xffffff })
          );
          vanity.position.set(cx + 0.5, 0.4, cz);
          group.add(vanity);

          // Mirror
          const mirror = new THREE.Mesh(
            new THREE.PlaneGeometry(0.9, 1.0),
            new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 1.0, roughness: 0.0 })
          );
          mirror.position.set(cx + 0.5, 1.4, cz - 0.31);
          mirror.rotation.y = Math.PI; // Face room? 
          // Actually, attach to wall.
          group.add(mirror);
        } else if (type.includes('dining')) {
          // Large Round Table
          const table = new THREE.Mesh(
            new THREE.CylinderGeometry(1.2, 1.2, 0.1, 32),
            new THREE.MeshStandardMaterial({ color: 0xefebe9 })
          );
          table.position.set(cx, 0.75, cz);
          table.castShadow = true;
          group.add(table);

          // Chairs around
          for (let i = 0; i < 4; i++) {
            const chair = new THREE.Mesh(
              new THREE.BoxGeometry(0.5, 0.5, 0.5),
              new THREE.MeshStandardMaterial({ color: 0x4e342e })
            );
            const angle = (i / 4) * Math.PI * 2;
            chair.position.set(cx + Math.cos(angle) * 1.0, 0.25, cz + Math.sin(angle) * 1.0);
            group.add(chair);
          }
        }
      }

      function updateUI() {
        const totalArea = houseLayout.rooms.reduce((sum, r) => sum + (r.width * r.depth), 0);
        document.getElementById('room-count').textContent = houseLayout.rooms.length;
        document.getElementById('total-area').textContent = totalArea.toFixed(0);

        // Sync back to localStorage so cost estimation uses correct area
        try {
          const projectInfo = JSON.parse(localStorage.getItem('projectInfo') || '{}');
          projectInfo.total_area = totalArea;
          projectInfo.room_count = houseLayout.rooms.length;
          localStorage.setItem('projectInfo', JSON.stringify(projectInfo));
          sessionStorage.setItem('projectInfo', JSON.stringify(projectInfo));
        } catch (e) { console.error("Sync error:", e); }

        const roomList = document.getElementById('room-list');
        roomList.innerHTML = houseLayout.rooms.map(room => {
          const area = (room.width * room.depth).toFixed(0);
          const color = getRoomColor(room.type).toString(16).padStart(6, '0');
          return `
            <div class="room-item">
              <div class="room-color" style="background-color:#${color}"></div>
              <span style="flex:1">${room.type}</span>
              <strong>${area} m¬≤</strong>
            </div>
          `;
        }).join('');
      }

      function updateLabels() {
        const container = document.getElementById('labels-container');
        container.innerHTML = '';

        if (!document.getElementById('toggle-labels').checked) return;

        houseLayout.rooms.forEach(room => {
          // Position at CEILING height (top of walls) to stay out of face
          const centerPos = new THREE.Vector3(
            room.x + room.width / 2,
            houseLayout.wallHeight,
            room.z + room.depth / 2
          );

          // Check distance to camera
          const dist = camera.position.distanceTo(centerPos);

          // Hide label if we are too close (inside the room) or too far
          // In Walk Mode, this prevents labels blocking the view
          if (dist < 6) return; // Hide if within 6 meters (inside/near)

          const worldPos = centerPos.clone().project(camera);

          const x = (worldPos.x * 0.5 + 0.5) * w;
          const y = (-worldPos.y * 0.5 + 0.5) * h;

          if (x > 0 && x < w && y > 0 && y < h && worldPos.z < 1) {
            const label = document.createElement('div');
            const className = room.type.toLowerCase().replace(/\s+/g, '');
            label.className = 'room-label ' + className;
            label.textContent = room.type;
            label.style.left = x + 'px';
            label.style.top = y + 'px';
            container.appendChild(label);
          }
        });
      }

      // --- TOUR MODE VARIABLES ---
      let isTourMode = false;
      let isTourPaused = false;
      let tourQueue = [];
      let currentTourTween = null;
      let tourIndex = 0;

      window.startTour = function () {
        if (isWalkMode) document.exitPointerLock();

        isTourMode = true;
        isTourPaused = false;
        tourIndex = 0;
        document.getElementById('tour-hud').style.display = 'flex';
        document.getElementById('btn-pause').style.display = 'inline-block';
        document.getElementById('btn-play').style.display = 'none';
        document.getElementById('tour-status').textContent = 'Starting Tour...';

        // Generate Queue: Entrance -> All Rooms -> Entrance
        tourQueue = [];

        // 1. Entrance
        const ent = houseLayout.rooms.find(r => r.type.toLowerCase().includes('entrance')) || houseLayout.rooms[0];
        if (ent) tourQueue.push(ent);

        // 2. All other rooms
        houseLayout.rooms.forEach(r => {
          if (r !== ent) tourQueue.push(r);
        });

        // 3. Back to start
        if (ent) tourQueue.push(ent);

        nextTourStep();
      };

      function nextTourStep() {
        if (!isTourMode || isTourPaused) return;
        if (tourIndex >= tourQueue.length) {
          stopTour();
          return;
        }

        const room = tourQueue[tourIndex];
        document.getElementById('tour-status').textContent = 'Visiting: ' + room.type;

        // Target position: Room Center + distance for better view
        const targetX = room.x + room.width / 2;
        const targetZ = room.z + room.depth / 2;

        // "Inside" Tour: Eye-level perspective
        // Move camera to a corner/entrance of the room to look continuously at the center
        const camOffsetX = -room.width / 2 + 1; // Near left edge
        const camOffsetY = 1.7; // Eye Level
        const camOffsetZ = -room.depth / 2 + 1; // Near front edge

        // Move Camera to inside position
        currentTourTween = new TWEEN.Tween(camera.position)
          .to({
            x: targetX + camOffsetX,
            y: camOffsetY,
            z: targetZ + camOffsetZ
          }, 6000) // 6s travel (Smooth walk)
          .easing(TWEEN.Easing.Quadratic.InOut)
          .onStart(() => {
            // Auto Open Elements
            autoOpenElements(room);
            // Look at Room Center
            new TWEEN.Tween(controls.target)
              .to({ x: targetX, y: 1.5, z: targetZ }, 3000)
              .start();
          })
          .onComplete(() => {
            tourIndex++;
            setTimeout(nextTourStep, 2000); // 2s pause to admire
          })
          .start();
      }

      function autoOpenElements(room) {
        // Find doors within room bounds (roughly)
        const roomMinX = room.x - 0.5;
        const roomMaxX = room.x + room.width + 0.5;
        const roomMinZ = room.z - 0.5;
        const roomMaxZ = room.z + room.depth + 0.5;

        // Helper to check bounds
        const isInRoom = (obj) => {
          return obj.position.x >= roomMinX && obj.position.x <= roomMaxX &&
            obj.position.z >= roomMinZ && obj.position.z <= roomMaxZ;
        };

        // Open Doors
        doorsGroup.traverse(d => {
          if (d.isMesh && isInRoom(d) && !d.userData.isOpen) {
            new TWEEN.Tween(d.rotation)
              .to({ y: d.rotation.y + Math.PI / 2 }, 1000)
              .start();
            d.userData.isOpen = true;
          }
        });

        // Open Windows (if movable, usually visual only, but lets try rotate/slide if structured)
        // For now, focus on doors as requested.
      }

      window.pauseTour = function () {
        isTourPaused = true;
        if (currentTourTween) currentTourTween.stop(); // Stop movement
        document.getElementById('btn-pause').style.display = 'none';
        document.getElementById('btn-play').style.display = 'inline-block';
        document.getElementById('tour-status').textContent = 'Paused';
      };

      window.resumeTour = function () {
        isTourPaused = false;
        nextTourStep(); // Restart step or continue? 
        // Simple resume: just go to next step or re-trigger current target.
        // Since we stopped tween, re-calling nextTourStep will start from current index to target
        document.getElementById('btn-pause').style.display = 'inline-block';
        document.getElementById('btn-play').style.display = 'none';
      };

      window.stopTour = function () {
        isTourMode = false;
        isTourPaused = false;
        if (currentTourTween) currentTourTween.stop();
        document.getElementById('tour-hud').style.display = 'none';
        document.getElementById('tour-status').textContent = '';
        // Reset view
        window.setView('iso');
      };

      // --- WALK MODE VARIABLES ---
      let walkControls;
      let moveForward = false;
      let moveBackward = false;
      let moveLeft = false;
      let moveRight = false;
      let canJump = false;
      let isWalkMode = false;

      let prevTime = performance.now();
      const velocity = new THREE.Vector3();
      const direction = new THREE.Vector3();
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      // Interactions
      let interactableObjects = [];

      window.showInstructions = function () {
        document.getElementById('instructions').style.display = 'block';
      };

      window.startWalk = function () {
        document.getElementById('instructions').style.display = 'none';

        if (!walkControls) {
          initWalkControls();
        }

        walkControls.lock();
      };

      function initWalkControls() {
        walkControls = new THREE.PointerLockControls(camera, document.body);

        walkControls.addEventListener('lock', function () {
          document.getElementById('instructions').style.display = 'none';
          document.getElementById('crosshair').style.display = 'block';
          document.getElementById('walk-hud').style.display = 'block'; // Show HUD
          isWalkMode = true;

          const ent = houseLayout.rooms.find(r => r.type.toLowerCase().includes('entrance')) || houseLayout.rooms[0];
          if (ent) {
            const x = ent.x + ent.width / 2;
            const z = ent.z + ent.depth / 2;
            camera.position.set(x, 1.7, z + 2);
            camera.lookAt(x, 1.7, z - 5);
          }
        });

        walkControls.addEventListener('unlock', function () {
          document.getElementById('crosshair').style.display = 'none';
          document.getElementById('walk-hud').style.display = 'none'; // Hide HUD
          isWalkMode = false;
        });

        scene.add(walkControls.getObject());

        const onKeyDown = function (event) {
          switch (event.code) {
            case 'ArrowUp':
            case 'KeyW':
              moveForward = true;
              break;
            case 'ArrowLeft':
            case 'KeyA':
              moveLeft = true;
              break;
            case 'ArrowDown':
            case 'KeyS':
              moveBackward = true;
              break;
            case 'ArrowRight':
            case 'KeyD':
              moveRight = true;
              break;
          }
        };

        const onKeyUp = function (event) {
          switch (event.code) {
            case 'ArrowUp':
            case 'KeyW':
              moveForward = false;
              break;
            case 'ArrowLeft':
            case 'KeyA':
              moveLeft = false;
              break;
            case 'ArrowDown':
            case 'KeyS':
              moveBackward = false;
              break;
            case 'ArrowRight':
            case 'KeyD':
              moveRight = false;
              break;
          }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        // Interaction Click
        document.addEventListener('click', function () {
          if (isWalkMode) {
            checkInteraction();
          }
        });
      }

      function checkInteraction() {
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

        // Collect doors and lights/switches
        const objects = [];
        doorsGroup.traverse(c => { if (c.isMesh) objects.push(c); });
        // Also check for furniture if needed, e.g. switches

        const intersects = raycaster.intersectObjects(objects);

        if (intersects.length > 0) {
          const obj = intersects[0].object;
          const dist = intersects[0].distance;

          if (dist < 3.0) { // Interaction range
            // Check if it's a door
            // Simple toggle rotation logic
            if (!obj.userData.isOpen) {
              // Open
              new TWEEN.Tween(obj.rotation)
                .to({ y: obj.rotation.y + Math.PI / 2 }, 500)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();
              obj.userData.isOpen = true;
            } else {
              // Close
              new TWEEN.Tween(obj.rotation)
                .to({ y: obj.rotation.y - Math.PI / 2 }, 500)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();
              obj.userData.isOpen = false;
            }
          }
        }
      }

      let walkTimer = 0;

      function checkHover() {
        if (!isWalkMode) return;
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const objects = [];
        doorsGroup.traverse(c => { if (c.isMesh) objects.push(c); });

        const intersects = raycaster.intersectObjects(objects);
        const crosshair = document.getElementById('crosshair');

        if (intersects.length > 0 && intersects[0].distance < 3.0) {
          crosshair.style.borderColor = '#00ff00';
          crosshair.style.transform = 'translate(-50%, -50%) scale(1.5)';
          crosshair.style.backgroundColor = 'rgba(0, 255, 0, 0.2)';
        } else {
          crosshair.style.borderColor = 'rgba(0,0,0,0.5)';
          crosshair.style.transform = 'translate(-50%, -50%) scale(1)';
          crosshair.style.backgroundColor = 'rgba(255, 255, 255, 0.4)';
        }
      }

      function animate() {
        requestAnimationFrame(animate);

        const time = performance.now();

        if (isWalkMode && walkControls.isLocked) {
          const delta = (time - prevTime) / 1000;

          velocity.x -= velocity.x * 10.0 * delta;
          velocity.z -= velocity.z * 10.0 * delta;

          velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

          direction.z = Number(moveForward) - Number(moveBackward);
          direction.x = Number(moveRight) - Number(moveLeft);
          direction.normalize(); // this ensures consistent movements in all directions

          if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
          if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

          walkControls.moveRight(-velocity.x * delta);
          walkControls.moveForward(-velocity.z * delta);

          // Head Bobbing
          if (moveForward || moveBackward || moveLeft || moveRight) {
            walkTimer += delta * 12; // Speed of bob
            camera.position.y = 1.7 + Math.sin(walkTimer) * 0.08; // Amount of bob
          } else {
            // Return to neutral
            camera.position.y = 1.7 + (camera.position.y - 1.7) * 0.9;
          }

          // Dynamic Crosshair
          checkHover();

        } else {
          controls.update();
        }

        TWEEN.update(); // We need TWEENjs for smooth animations, let's include it or write simple lerp.
        // wait, TWEEN is not imported. I should import it or use simple boolean toggle or setInterval.
        // Let's use simple logic for now or add TWEEN script. I'll add TWEEN script to head.

        renderer.render(scene, camera);
        updateLabels();

        prevTime = time;
      }



      window.setView = function (viewName) {
        if (isWalkMode) return; // Disable views in walk mode

        document.querySelectorAll('.view-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.view === viewName);
        });

        const views = {
          'iso': { pos: [50, 40, 50], target: [12, 0, 10] },
          'top': { pos: [12, 80, 10], target: [12, 0, 10] },
          'front': { pos: [12, 2, -18], target: [12, 1.5, 0] },
          'interior': { pos: [12, 6, 8], target: [12, 2, 10] }
        };

        const view = views[viewName] || views['iso'];
        camera.position.set(...view.pos);
        controls.target.set(...view.target);
        controls.update();
      };

      document.querySelectorAll('.view-btn').forEach(btn => {
        btn.addEventListener('click', () => window.setView(btn.dataset.view));
      });

      document.getElementById('toggle-furniture').addEventListener('change', e => {
        furnitureGroup.visible = e.target.checked;
      });

      document.getElementById('toggle-roof').addEventListener('change', e => {
        roofGroup.visible = e.target.checked;
      });

      document.getElementById('toggle-doors').addEventListener('change', e => {
        doorsGroup.visible = e.target.checked;
      });

      document.getElementById('toggle-windows').addEventListener('change', e => {
        windowsGroup.visible = e.target.checked;
      });

      document.getElementById('toggle-auto-rotate').addEventListener('change', e => {
        controls.autoRotate = e.target.checked;
        controls.autoRotateSpeed = 0.8;
      });

      window.goBack = () => window.history.length > 1 ? window.history.back() : window.location.href = 'index.html';

      window.downloadVisualization = () => {
        try {
          const link = document.createElement('a');
          link.download = `dream-house-${Date.now()}.png`;
          link.href = renderer.domElement.toDataURL('image/png');
          link.click();
        } catch (e) {
          alert('Screenshot captured!');
        }
      };

      window.export3DModel = () => {
        const exporter = new THREE.GLTFExporter();
        // Parse the scene
        exporter.parse(scene, function (result) {
          const output = JSON.stringify(result, null, 2);
          const blob = new Blob([output], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);

          const link = document.createElement('a');
          link.style.display = 'none';
          document.body.appendChild(link);
          link.href = url;
          link.download = `my-dream-house.gltf`;
          link.click();

          URL.revokeObjectURL(url);
          document.body.removeChild(link);
        }, {
          binary: false // .gltf (text)
        });
      };

      buildHouse();
      animate();
      window.setView('iso');

      setTimeout(() => {
        const loading = document.getElementById('loading-screen');
        loading.style.opacity = '0';
        loading.style.transition = 'opacity 0.6s';
        setTimeout(() => loading.style.display = 'none', 600);
      }, 1000);

      window.addEventListener('resize', () => {
        w = window.innerWidth;
        h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      });
    }
  </script>
</body>

</html>